input:
  http_server:
    address: "0.0.0.0:4196"
    path: "/events"
    allowed_verbs: ["POST"]

pipeline:
  processors:
    # Parse the JSON input and extract the event
    - bloblang: |
        meta event_value = content().parse_json().event

    # Use sql_select processor for SELECT queries
    - sql_select:
        driver: "mysql"
        dsn: "myuser:mypassword@tcp(localhost:3306)/mydatabase"
        table: "subscriptions"
        columns: ["callback_url"]
        where: "event_name = ?"
        args_mapping: 'root = [meta("event_value")]'

    # Add error handling for SQL errors
    - catch:
        - bloblang: |
            root = this
            root.debug.sql_error = error()
            root.debug.sql_error_occurred = true

    # Format each row as a complete message with event information
    - bloblang: |
        root = this.map_each(url -> {
          "callback_url": url.callback_url,
          "event": meta("event_value")
        })

    # Split the array into individual messages
    - unarchive:
        format: json_array

    # Format each message for HTTP client
    - bloblang: |
        meta url = this.callback_url
        root = {
          "event": this.event
        }

output:
  # Output to both stdout and http_client
  broker:
    outputs:
      - stdout: {}
      - http_client:
          url: "${! meta(\"url\") }"
          verb: "POST"
          headers:
            Content-Type: "application/json"
